<html>
  <head>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta
      http-equiv="content-type"
      content="text/html; charset=utf-8"
      lang="en"
    />
    <meta content="EMC Terra Nova map replacemen" property="og:title" />
    <meta
      content="EarthMC Terra Nova map replacement"
      property="og:description"
    />
    

    <link rel="stylesheet" href="./css/main.css" />
    <script src="js/leaflet.js"></script>

    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"
      integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A=="
      crossorigin=""
    />

    <script
      type="text/javascript"
      src="https://code.jquery.com/jquery-latest.js"
    ></script>

    <link rel="icon" type="image/x-icon" href="assets/logo.ico">

    <title>EMC Terra Nova map replacement</title>
  </head>
  <body>
    
    
    
    <div id="map">
      <button id="Toggle" class="Toggle">Toggle Towny borders</button>
      <button id="IRLtoggle" class="Toggle">Toggle countries borders</button>
    </div>
    <script>
    
      function getCoordinatesFromURL() {
    const params = new URLSearchParams(window.location.search);
    const y = parseFloat(params.get("y"));
    const x = parseFloat(params.get("x"));
    const zoom = parseInt(params.get("zoom"), 10);

    if (!isNaN(y) && !isNaN(x) && !isNaN(zoom)) {
        return { y, x, zoom };
    }

    // Default fallback coordinates and zoom level
    return { y: 0, x: 0, zoom: -3 };
}
    const { y, x, zoom } = getCoordinatesFromURL();
      var emcmap = L.map("map", {
        crs: L.CRS.Simple,
      }).setView([y, x], zoom);


    const geoJsonFeatures = []
async function FetchMap(){
  const response = await fetch("./assets/markers_earth.json")
if(response.status !== 200){ 
  return console.log("Error: status code" + response.status)
  
}
const data = await response.json()
console.log(data)
  const areas = data.sets['townyPlugin.markerset'].areas

  for (const areaID in areas){
    const area = areas[areaID]
    const coords = area.x.map((x, index) => [x, -area.z[index]-64]) 

    const feature = {
        "type": "Feature",
       "properties": {"name":area.desc,"color": area.color, "fillColor":area.fillcolor, "show_on_map": true},
        "geometry": {
          "type": "Polygon",
          "coordinates": [coords],
          
          },
      }
      geoJsonFeatures.push(feature)
  }
}
let geoJsonLayer
function onEachFeatur(feature, layer) {
        if (feature.properties && feature.properties.name) {
            layer.bindPopup(feature.properties.name);
        }
    }
FetchMap().then(( ) => {
  console.log(geoJsonFeatures)
  
var FeatureCollection =   { "type": "FeatureCollection", "features": geoJsonFeatures }
  console.log(FeatureCollection)
geoJsonLayer = L.geoJson(FeatureCollection, { style: function(feature){ return {color: feature.properties.color, fillColor:feature.properties.fillColor, opacity:0.65, weight:1 } }, filter: function(feature, layer){return feature.properties.show_on_map}, onEachFeature: onEachFeatur }).addTo(emcmap)

})
$("#Toggle").click(function(){
  geoJsonFeatures.forEach(feature => {
          if(feature.properties.show_on_map == true){
            feature.properties.show_on_map = false;
          }else feature.properties.show_on_map = true
        });

       
        emcmap.removeLayer(geoJsonLayer);
        var FeatureCollection =   { "type": "FeatureCollection", "features": geoJsonFeatures }
        
        geoJsonLayer = L.geoJson(FeatureCollection, {
            style: function(feature) {
                return {
                    color: feature.properties.color,
                    fillColor: feature.properties.fillColor,
                    opacity: 0.65,
                    weight: 1
                };
            },
            filter: function(feature, layer) {
                return feature.properties.show_on_map;
            },
            onEachFeature: onEachFeatur
        }).addTo(emcmap);
  }); 

let IRLlayer
  const IRLCountries = []
async function FetchIRL(){
  const response = await fetch("./assets/markers_earth.json")
if(response.status !== 200){ 
  return console.log("Error: status code" + response.status)
  
}
const data = await response.json()
console.log(data)
  const lines = data.sets['borders.Country Borders'].lines

  for (const linesID in lines){
    const line = lines[linesID]
    const coords = line.x.map((x, index) => [x, -line.z[index]-64]) 

    const feature = {
      type: "Feature",
            properties: {
                show_on_map: false
            },
            geometry: {
                type: "LineString",
                coordinates: coords,
            }
    }
      IRLCountries.push(feature)
  }
}

FetchIRL().then(( ) => {
  
 
  var IRLCountriesCollection =   { "type": "FeatureCollection", "features": IRLCountries }
  console.log(IRLCountriesCollection)
IRLlayer = L.geoJson(IRLCountriesCollection, {
            style: {
    "color": "#000000",
    "weight": 4,
    "opacity": 0.5,
},
            filter: function(feature, layer) {
                return feature.properties.show_on_map;
            },
            
        }).addTo(emcmap)
})

 
$("#IRLtoggle").click(function(){
  IRLCountries.forEach(feature => {
          if(feature.properties.show_on_map == true){
            feature.properties.show_on_map = false;
          }else feature.properties.show_on_map = true
        });

        
        emcmap.removeLayer(IRLlayer);
        var FeatureCollection =   { "type": "FeatureCollection", "features": IRLCountries }
        
        IRLlayer = L.geoJson(FeatureCollection, {
            style: {
    "color": "#000000",
    "weight": 4,
    "opacity": 0.5,
},
            filter: function(feature, layer) {
                return feature.properties.show_on_map;
            },
            
        }).addTo(emcmap);
  }); 

      


      // EMC background tiles
      L.tileLayer(
        "./assets/Tiles/zzzzz_nova/{x1}_{y1}.webp",
        {
          maxZoom: -4,
          minZoom: -4,
          tileSize: 128,
        }
      ).addTo(emcmap);
      L.tileLayer(
        "./assets/Tiles/zzzz_nova/{x2}_{y2}.webp",
        {
          maxZoom: -3,
          minZoom: -3,
          tileSize: 128,
        }
      ).addTo(emcmap);
      L.tileLayer(
        "./assets/Tiles/zzz_nova/{x3}_{y3}.webp",
        {
          maxZoom: -2,
          minZoom: -2,
          tileSize: 128,
        }
      ).addTo(emcmap);
      L.tileLayer(
        "./assets/Tiles/zz_nova/{x4}_{y4}.webp",
        {
          maxZoom: -1,
          minZoom: -1,
          tileSize: 128,
        }
      ).addTo(emcmap);
      L.tileLayer(
        "./assets/Tiles/z_nova/{x5}_{y5}.webp",
        {
          maxZoom: 0,
          minZoom: 0,
          tileSize: 128,
        }
      ).addTo(emcmap);
      L.tileLayer("./assets/Tiles/nova/{x}_{y6}.webp", {
        maxZoom: 2,
        maxNativeZoom: 1,
        minZoom: 1,
        tileSize: 128,
      }).addTo(emcmap);
    </script>
    
  </body>
</html>
